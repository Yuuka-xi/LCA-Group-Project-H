#best time line
rm (list = ls())

library(timelineS)
library(lubridate)
library(ggplot2)
library(dplyr)
library(reshape2)
library(rPref)
library(mco)
library(MASS)



plot.timeline <- function(lifetime, events.name, start.Date, plot.Name) {
  dataP <- data.frame(
    Events = events.name,
    Event_Dates = ymd(start.Date) + years(lifetime)
  )
  par(mar = c(4, 4, 4, 2))
  timelineS(
    dataP,
    main = plot.Name,
    labels = events.name,
    label.direction = "up",
    label.position = 3,
    label.cex = 0.6  #Front size
  )
}


dist.events <- function (lifetime, events, start.Date, option.Name, do.plot = TRUE) {
  events <- sort(events, decreasing = TRUE)
  distribution.events <- sapply(events, seq, from = 0, to = lifetime)
  all.events <- melt(distribution.events)
  colnames(all.events) <- c("frequency", "event")
  all.events <- all.events[order(all.events$frequency),]
  
  # Set all events occurring at year 0 as "DC" 
  #all.events$event[all.events$frequency == 0] <- "DC"
  
  # Remove maintenance events occurring at the same year as END
  # while keeping the END event as the life-cycle boundary
  all.events <- subset(all.events, !(frequency == lifetime & event != "END"))
  
  # Use a de-duplicated version of the timeline only for plotting,
  # to avoid overlapping labels in the same year
  if (do.plot) {
    unique.events <- all.events[!duplicated(all.events$frequency), ]
    plot.timeline(unique.events$frequency, unique.events$event, start.Date, option.Name)
  }
  
  return(all.events)  # Return full event list
}


# Yuuka: Added Function combine.lifeTimelinesN
# Combine maintenance timelines for N subsystems
combine.lifeTimelinesN <- function(timelines, durs, rule = c("max", "sum")) {
  # timelines: list of dist.Events outputs (each has $frequency and $event)
  # durs:      list of named numeric vectors, mapping event name -> duration (days)
  # rule:      how to combine simultaneous downtimes ("max" to assume bundling)
  rule <- match.arg(rule)
  
  if (!is.list(timelines) || !is.list(durs)) {
    stop("timelines and durs must both be lists.")
  }
  if (length(timelines) != length(durs)) {
    stop("timelines and durs must have the same length.")
  }
  
  n <- length(timelines) # n = 6
  
  # Collect all unique years across subsystems
  all_years <- sort(unique(unlist(lapply(timelines, function(tl) tl$frequency))), decreasing = FALSE)
  
  base <- list(
    frequency = all_years, 
    Names = rep("", length(all_years)), 
    duration = rep(0, length(all_years)) 
  )
  
  # Optional: enforce start/end labels if years include 0 and lifetime
  #base$Names[base$frequency == 0] <- "DC"
  
  # Loop over each year 开始一些烧脑的循环嵌套，说实话我没看懂… 能跑就行吧
  for (k in seq_along(all_years)) {
    yr <- all_years[k]
    
    events_this_year <- c()
    durations_this_year <- c()
    
    for (s in seq_len(n)) {
      tl <- timelines[[s]]
      dur_map <- durs[[s]]
      
      ev <- tl$event[tl$frequency == yr]
      if (length(ev) == 0) next
      
      # In your dist.Events, each year is unique, so length(ev) is usually 1
      for (e in ev) {
        events_this_year <- c(events_this_year, e)
        
        # Look up duration; if missing, treat as 0 and warn once
        d <- dur_map[names(dur_map) == e]
        if (length(d) == 0) {
          d <- 0
          # You can comment this out if too noisy
          warning(sprintf("No duration found for event '%s' (subsystem %d). Using 0.", e, s))
        }
        durations_this_year <- c(durations_this_year, as.numeric(d))
      }
    }
    
    # Fill outputs for this year
    if (length(events_this_year) > 0) {
      base$Names[k] <- paste(events_this_year, collapse = " + ")
      base$duration[k] <- if (rule == "max") max(durations_this_year) else sum(durations_this_year)
    } else {
      base$Names[k] <- ""
      base$duration[k] <- 0
    }
  }
  
  # Put END label if the max year is lifetime (optional)
  base$Names[base$frequency == max(base$frequency)] <- "END"
  
  return(base)
}


lifetime <- 120
start.Date <- "2026-01-01"

events.PCF <- c(
  CR.pcf   = 18,
  JM.pcf   = 18,
  PR.pcf   = 60,
  END      = lifetime
)

events.GCW <- c(
  DC.gcw   = 9,
  GR.gcw   = 9,
  IR.gcw   = 60,
  END      = lifetime
)

events.BRC <- c(
  SR.brcs   = 61,
  CSJR.brcs = 20,
  CT.brcp   = 16,
  SG.brcf   = 30,
  END      = lifetime
)

events.STB <- c(
  MP.stb = 20,
  FR.stb = 20,
  END    = lifetime
)

events.RLWC <- c(
  SSRC.rlw_slp = 51,
  #RM.rlw_rls   = 5,
  FRR.rlw_rls  = 80,
  END      = lifetime
)

events.RLWT <- c(
  rlwt_TS.full = 30,
  rlwt_SB.geo   = 90,
  FRR.rlwt  = 66,
  END      = lifetime
)

maintenance.PCF <- dist.events(lifetime, events.PCF, start.Date, "PCF")
maintenance.GCW <- dist.events(lifetime, events.GCW, start.Date, "GCW")
maintenance.BRC <- dist.events(lifetime, events.BRC, start.Date, "BRC")
maintenance.STB <- dist.events(lifetime, events.STB, start.Date, "STB")
maintenance.RLWC <- dist.events(lifetime, events.RLWC, start.Date, "RLWC")
maintenance.RLWT <- dist.events(lifetime, events.RLWT, start.Date, "RLWT")

#Just to check the output, you can comment it
maintenance.PCF
maintenance.GCW
maintenance.BRC
maintenance.STB
maintenance.RLWC
maintenance.RLWT


# =========================
# P15-P16
LCI.materials <- read.csv(file.choose(), stringsAsFactors = FALSE)
events_input <- read.csv(file.choose(), stringsAsFactors = FALSE)

# check
# setdiff(events_input$material, LCI.materials$material)

# equal to the LCA.bridge function in the tutorial
LCA.byEvents <- function(events_input, timeline, LCI_materials) {
  
  # 1) Count the number of occurrences of each event over the life cycle
  event_freq <- as.data.frame(table(timeline$event), stringsAsFactors = FALSE)
  colnames(event_freq) <- c("event_code", "n_occurrences")
  event_freq <- subset(event_freq, !(event_code %in% c("DC", "END")))
  
  # 2) Merge event frequencies into events_input
  df <- merge(events_input, event_freq, by = "event_code", all.x = TRUE)
  df$n_occurrences[is.na(df$n_occurrences)] <- 0  # timeline里没出现的事件 → 0次
  
  # 3) Build an LCI lookup table using both material and scope as keys
  LCI_keyed <- rbind(
    transform(LCI_materials, join_key = material),
    transform(LCI_materials, join_key = scope)
  )
  LCI_keyed <- LCI_keyed[!is.na(LCI_keyed$join_key) & LCI_keyed$join_key != "", ]
  
  # 4) Match events_input materials with the LCI lookup table
  df$join_key <- df$material
  df2 <- merge(df, LCI_keyed, by = "join_key", all.x = TRUE)
  
  # # 5) Check for unmatched materials or scopes
  # if (any(is.na(df2$energy))) {
  #   missing <- unique(df2$join_key[is.na(df2$energy)])
  #   stop(paste("These event_input.material values did not match any LCI material/scope:", 
  #              paste(missing, collapse = ", ")))
  # }
  
  # 6) Compute life-cycle material quantities
  df2$total_material <- df2$quantities * df2$amount_per_event * df2$n_occurrences
  
  # 7)Compute life-cycle environmental impacts
  df2$Energy_LC <- df2$total_material * df2$energy
  df2$CO2_LC    <- df2$total_material * df2$CO2
  df2$NOx_LC    <- df2$total_material * df2$NOx
  df2$Cost_LC   <- df2$total_material * df2$Cost
  
  LCA.results <- list(
    Energy = sum(df2$Energy_LC),
    CO2    = sum(df2$CO2_LC),
    NOx    = sum(df2$NOx_LC),
    Cost   = sum(df2$Cost_LC),
    detail = df2   # for debug
  )
  return(LCA.results)
}


# LCA data

events_input.PCF <- subset(events_input, system == "PCF")
events_input.GCW <- subset(events_input, system == "GCW")
events_input.BRC  <- subset(events_input, system == "BRC")
events_input.STB <- subset(events_input, system == "STB")
events_input.RLWC <- subset(events_input, system == "RLWC")
events_input.RLWT <- subset(events_input, system == "RLWT")

LCA.PCF  <- LCA.byEvents(events_input.PCF,  maintenance.PCF,  LCI.materials)
LCA.GCW  <- LCA.byEvents(events_input.GCW,  maintenance.GCW,  LCI.materials)
LCA.BRC  <- LCA.byEvents(events_input.BRC,  maintenance.BRC,  LCI.materials)
LCA.STB  <- LCA.byEvents(events_input.STB,  maintenance.STB,  LCI.materials)
LCA.RLWC <- LCA.byEvents(events_input.RLWC, maintenance.RLWC, LCI.materials)
LCA.RLWT <- LCA.byEvents(events_input.RLWT, maintenance.RLWT, LCI.materials)

# Quick view for debug, you can comment it
LCA.PCF
LCA.GCW
LCA.BRC
LCA.STB
LCA.RLWC
LCA.RLWT


integrated.Design <- as.data.frame(list(
  Energy = LCA.PCF$Energy  + LCA.GCW$Energy  + LCA.BRC$Energy  + LCA.STB$Energy  + LCA.RLWC$Energy  + LCA.RLWT$Energy,
  CO2    = LCA.PCF$CO2     + LCA.GCW$CO2     + LCA.BRC$CO2     + LCA.STB$CO2     + LCA.RLWC$CO2     + LCA.RLWT$CO2,
  NOx    = LCA.PCF$NOx     + LCA.GCW$NOx     + LCA.BRC$NOx     + LCA.STB$NOx     + LCA.RLWC$NOx     + LCA.RLWT$NOx,
  Cost   = LCA.PCF$Cost    + LCA.GCW$Cost    + LCA.BRC$Cost    + LCA.STB$Cost    + LCA.RLWC$Cost    + LCA.RLWT$Cost
))
integrated.Design


# Convert environmental impacts into monetary costs
Energy.costs <- 0.081
CO2.unitcost <- 285.6 # per metric tone 
NOx.unitCost <- 11.72 # per metric tone

integrated.Design <- mutate(
  integrated.Design,
  TotalCosts = Energy * Energy.costs +
    (CO2/1000) * CO2.unitcost +
    (NOx/1000) * NOx.unitCost + 
    Cost
)

integrated.Design

# ----P18-P22-----

fitness <- function(x) {
  
  # --------------------------------
  # Output vector (6 objectives)
  # --------------------------------
  z <- numeric(6)
  
  # --------------------------------
  # Round GA decision variables
  # --------------------------------
  x <- round(x, 0)
  
  # --------------------------------
  # Decision variables order
  # --------------------------------
  # pcf  : 1–3
  # gcw  : 4–6
  # brc  : 7–10   (includes brcf)
  # stb  : 11–12
  # rlwc : 13–14
  # rlwt : 15–17
  
  y <- expand.grid(
    CR.pcf = x[1],
    JM.pcf = x[2],
    PR.pcf = x[3],
    
    DC.gcw = x[4],
    GR.gcw = x[5],
    IR.gcw = x[6],
    
    SR.brcs   = x[7],
    CSJR.brcs = x[8],
    CT.brcp   = x[9],
    SG.brcf   = x[10],   # <-- moved into BRC
    
    MP.stb = x[11],
    FR.stb = x[12],
    
    SSRC.rlw_slp = x[13],
    FRR.rlw_rls  = x[14],
    
    rlwt_TS.full = x[15],
    rlwt_SB.geo  = x[16],
    FRR.rlwt     = x[17]
  )
  
  # --------------------------------
  # Event durations (half-duration assumption)
  # --------------------------------
  dur.pcf  <- unlist(y[1:3]   )
  dur.gcw  <- unlist(y[4:6]   )
  dur.brc  <- unlist(y[7:10]  )   # <-- includes SG.brcf
  dur.stb  <- unlist(y[11:12] )
  dur.rlwc <- unlist(y[13:14] )
  dur.rlwt <- unlist(y[15:17] )
  
  # --------------------------------
  # Distribute events per system
  # --------------------------------
  dist.1 <- apply(y[1:3], 1, function(ev) dist.events(lifetime = lifetime, events = ev, start.Date = start.Date, option.Name = "PCF", do.plot = FALSE))
  dist.2 <- apply(y[4:6], 1, function(ev) dist.events(lifetime = lifetime, events = ev, start.Date = start.Date, option.Name = "GCW", do.plot = FALSE))
  dist.3 <- apply(y[7:10], 1, function(ev) dist.events(lifetime = lifetime, events = ev, start.Date = start.Date, option.Name = "BRC", do.plot = FALSE))  # <-- includes brcf
  dist.4 <- apply(y[11:12], 1, function(ev) dist.events(lifetime = lifetime, events = ev, start.Date = start.Date, option.Name = "STB", do.plot = FALSE))
  dist.5 <- apply(y[13:14], 1, function(ev) dist.events(lifetime = lifetime, events = ev, start.Date = start.Date, option.Name = "RLWC", do.plot = FALSE))
  dist.6 <- apply(y[15:17], 1, function(ev) dist.events(lifetime = lifetime, events = ev, start.Date = start.Date, option.Name = "RLWT", do.plot = FALSE))
  
  # --------------------------------
  # Combine results
  # --------------------------------
  results <- combine.lifeTimelinesN(
    timelines = list(
      dist.1[[1]],
      dist.2[[1]],
      dist.3[[1]],
      dist.4[[1]],
      dist.5[[1]],
      dist.6[[1]]
    ),
    durs = list(
      dur.pcf,
      dur.gcw,
      dur.brc,
      dur.stb,
      dur.rlwc,
      dur.rlwt
    ),
    rule = "max"
  )
  
  # Objective 1: total duration
  z[1] <- sum(results[["duration"]])
  
  # Objective 2: minimum distance between interventions (negated)
  z[2] <- -min(abs(results$frequency[1:(length(results$frequency) - 1)] - results$frequency[2:length(results$frequency)]))
  
  # -------------------------------------------------------
  # LCA by system
  # -------------------------------------------------------
  product.1.pcf  <- LCA.byEvents(events_input.PCF,  dist.1[[1]], LCI.materials)
  product.2.gcw  <- LCA.byEvents(events_input.GCW,  dist.2[[1]], LCI.materials)
  product.3.brc  <- LCA.byEvents(events_input.BRC,  dist.3[[1]], LCI.materials)   # <-- includes brcf
  product.4.stb  <- LCA.byEvents(events_input.STB,  dist.4[[1]], LCI.materials)
  product.5.rlwc <- LCA.byEvents(events_input.RLWC, dist.5[[1]], LCI.materials)
  product.6.rlwt <- LCA.byEvents(events_input.RLWT, dist.6[[1]], LCI.materials)
  
  integrated.system <- as.data.frame(list(
    Energy =
      product.1.pcf$Energy +
      product.2.gcw$Energy +
      product.3.brc$Energy +
      product.4.stb$Energy +
      product.5.rlwc$Energy +
      product.6.rlwt$Energy,
    
    CO2 =
      product.1.pcf$CO2 +
      product.2.gcw$CO2 +
      product.3.brc$CO2 +
      product.4.stb$CO2 +
      product.5.rlwc$CO2 +
      product.6.rlwt$CO2,
    
    NOx =
      product.1.pcf$NOx +
      product.2.gcw$NOx +
      product.3.brc$NOx +
      product.4.stb$NOx +
      product.5.rlwc$NOx +
      product.6.rlwt$NOx
  
  ))
  
  integrated.system <- mutate(
    integrated.system,
    Costs = (Energy * Energy.costs + CO2 * CO2.unitcost + NOx * NOx.unitCost +  product.1.pcf$Cost +
               product.2.gcw$Cost +
               product.3.brc$Cost +
               product.4.stb$Cost +
               product.5.rlwc$Cost +
               product.6.rlwt$Cost) 
  )
  
  # -------------------------------------------------------
  # Output vector
  # -------------------------------------------------------
  z[3] <- integrated.system$Energy
  z[4] <- integrated.system$CO2
  z[5] <- integrated.system$NOx
  z[6] <- integrated.system$Costs
  
  return(z)
}


# ---------------------------------------------------------
# NSGA-II RUN
# ---------------------------------------------------------
r2 <- nsga2(
  fitness,
  idim = 17,
  odim = 6,
  generations = 10,
  popsize = 100,
  lower.bounds = c(
    12, 15, 40,    # pcf
    5, 8, 40,      # gcw
    50, 20, 15,    # brcs/brcp
    30,            # brcf
    3, 10,         # stb
    40, 60,         # rlwc
    15, 80, 60     # rlwt
  ),
  upper.bounds = c(
    18, 25, 60,
    10, 14, 60,
    70, 30, 25,
    50,
    7, 20,
    60, 100,
    30, 120, 100
  )
)  

# ---------------------------------------------------------
# Convert results
# ---------------------------------------------------------
r2Results <- as.data.frame(r2$value)
outNames <- c("duration", "interv.dist", "energy", "co2", "nox", "cost")
colnames(r2Results) <- outNames

pareto3 <- as.data.frame(paretoFront(r2))
colnames(pareto3) <- outNames

# ---------------------------------------------------------
# Pareto plot (Duration vs Cost)
# ---------------------------------------------------------
ggplot(r2Results, aes(x = duration, y = cost)) +
  geom_point(shape = 21) +
  geom_point(data = pareto3, size = 3, color = "red") +
  geom_line(data = pareto3, color = "blue") +
  labs(
    title = "Pareto Front: Duration vs Cost",
    x = "Total Duration of Interventions",
    y = "Total Cost (€)"
  ) +
  theme_minimal()

# ---------------------------------------------------------
# Input + Output table
# ---------------------------------------------------------
input.params <- round(r2$par, 0)

all.results <- cbind(input.params, r2Results, r2$pareto.optimal)

colnames(all.results) <- c(
  "CR.pcf","JM.pcf","PR.pcf",
  "DC.gcw","GR.gcw","IR.gcw",
  "SR.brcs","CSJR.brcs","CT.brcp",
  "SG.brcf","MP.stb","FR.stb",
  "SSRC.rlw_slp","FRR.rlw_rls",
  "rlwt_TS.full","rlwt_SB.geo","FRR.rlwt",
  "duration","interv.dist","energy","co2","nox","cost",
  "pareto"
)

# ---------------------------------------------------------
# Parallel coordinates
# ---------------------------------------------------------
library(MASS)
par(mfrow = c(1,1))
parcoord(
  all.results[, 1:23],
  var.label = TRUE,
  col = ifelse(all.results$pareto == TRUE, "indianred", "skyblue2"),
  lty = ifelse(all.results$pareto == TRUE, 1, 3),
  lwd = ifelse(all.results$pareto == TRUE, 3, 1)
)

# 1. Filtrar solo las soluciones óptimas (Rojas)
pareto_only <- all.results[all.results$pareto == TRUE, ]

# 2. Seleccionar las 5 soluciones más baratas (puedes cambiar 'cost' por 'co2')
top_5_best <- head(pareto_only[order(pareto_only$cost), ], 15)

# Ver los intervalos de mantenimiento de las 5 mejores soluciones
print(top_5_best[, 1:23])
